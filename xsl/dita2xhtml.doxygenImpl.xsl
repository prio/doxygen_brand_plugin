<?xml version="1.0" encoding="UTF-8" ?>
<!--
 | (C) Copyright Jonathan Harrington 2011. All Rights Reserved.
 *-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
				xmlns:dita2html="http://dita-ot.sourceforge.net/ns/200801/dita2html"
				xmlns:ditamsg="http://dita-ot.sourceforge.net/ns/200704/ditamsg">

<xsl:template name="gen-user-styles">
	<link href="tabs.css" rel="stylesheet" type="text/css"/>    
	<link href="doxygen.css" rel="stylesheet" type="text/css"/>	
</xsl:template>

<!-- Add wrapper div elements -->
<xsl:template match="*[contains(@class, ' topic/topic ')]" mode="chapterBody">
<body>
	<div id="top">
		<div id="titlearea">
		</div>
		
		<div id="navrow1" class="tabs">
			<ul class="tablist">
				<li><a href="index.html"><span>Main Page</span></a></li>
				<li><a href="pages.html"><span>Related Pages</span></a></li>
				<li><a href="modules.html"><span>Modules</span></a></li>
				<li class="current"><a href="annotated.html"><span>Data Structures</span></a></li>
				<li><a href="files.html"><span>Files</span></a></li>
			</ul>
		</div>
		
		<div id="navrow2" class="tabs2">
			<ul class="tablist">
				<li><a href="annotated.html"><span>Data Structures</span></a></li>
				<li><a href="functions.html"><span>Data Fields</span></a></li>
			</ul>
		</div>
	</div>

	<div class="header">
		<div class="summary">
			<a href="#pub-attribs">Data Fields</a>
		</div>

		<div class="headertitle">
			<div class="title">
  				<xsl:apply-templates select="../*[contains(@class,' apiClassifier/apiClassifier ') or
                         			         ../contains(@class, ' apiPackage/apiPackage ')]/*[contains(@class, ' topic/title ')]" mode="title" />			
			</div>
		</div>
	</div>

	<div class="contents">
		<xsl:apply-templates />
	</div>

	<hr class="footer" />
	<address class="footer">
		<small>
			Generated by <a href="http://www.doxygen.org/index.html"> <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.7.4
		</small>
	</address>
</body>
</xsl:template>

<!--  cxx overrides  -->

<!-- Define/Function/Enumeration/Typedef/Variable Title -->
<xsl:template match="*[contains(@class, ' apiOperation/apiOperation ') or
						 contains(@class, ' apiValue/apiValue ')]/*[contains(@class, ' topic/title ')]" mode="title">
  <!-- Anchor added for link inserter which puts an id on apiName elements -->
  <xsl:if test="@id">
      <xsl:element name="a">
        <xsl:attribute name="name" select="@id"/>
        <xsl:comment></xsl:comment>
      </xsl:element>
  </xsl:if>
  <xsl:call-template name="sect-heading">
    <xsl:with-param name="defaulttitle"><xsl:apply-templates select="." mode="cxxapiref.title-fmt"/></xsl:with-param>
  </xsl:call-template>
  <xsl:apply-templates select="../*[contains(@class, ' cxxFile/cxxFileAPIItemLocation ')]/*[contains(@class, ' cxxFile/cxxFileDeclarationFile ')]" mode="include"/>    
</xsl:template>

<!-- Hide duplicate title -->
<xsl:template match="*[contains(@class,' apiClassifier/apiClassifier ') or
                     contains(@class, ' apiPackage/apiPackage ')]/*[contains(@class, ' topic/title ')]">
</xsl:template>

<!--  Wrap includes in code tags -->
<xsl:template match="*[contains(@class, ' cxxClass/cxxClassDeclarationFile ') or
                       contains(@class, ' cxxStruct/cxxStructDeclarationFile ') or
                       contains(@class, ' cxxUnion/cxxUnionDeclarationFile ') or
                       contains(@class, ' cxxFile/cxxFileDeclarationFile ')]"
              mode="include">
	<code>
		<xsl:apply-templates select="."  mode="section-fmt" />
	</code>
</xsl:template>

<!-- FIXME: Should look for user set system include paths -->
<xsl:template match="*[contains(@class, ' cxxClass/cxxClassDeclarationFile ') or
                       contains(@class, ' cxxStruct/cxxStructDeclarationFile ') or
                       contains(@class, ' cxxUnion/cxxUnionDeclarationFile ') or
                       contains(@class, ' cxxFile/cxxFileDeclarationFile ')]" mode="section-fmt">
    <xsl:variable name="flagrules">
   <xsl:call-template name="getrules"/>
 </xsl:variable>
 <xsl:call-template name="start-revflag">
   <xsl:with-param name="flagrules" select="$flagrules"/>  
 </xsl:call-template>
    <xsl:variable name="includePath" select="@value"/>
      #include 
          <xsl:choose>
              <xsl:when test="contains(@value, 'include')">
                  &lt;<xsl:value-of select="substring-after($includePath,'include/')"/>&gt;
              </xsl:when>
              <xsl:otherwise>
                  <xsl:variable name="includeFile">
                      <xsl:call-template name="substring-after-last">
                          <xsl:with-param name="delimiter" select="'/'"/>
                          <xsl:with-param name="string" select="$includePath"/>
                      </xsl:call-template>                    
                  </xsl:variable>
                  &quot;<xsl:value-of select="$includeFile"/>&quot;
              </xsl:otherwise>
          </xsl:choose>
    <xsl:call-template name="end-revflag">
   <xsl:with-param name="flagrules" select="$flagrules"/>  
 </xsl:call-template>    
</xsl:template>

<!--  Hide class signature -->
<xsl:template match="*[contains(@class, ' cxxClass/cxxClassDefinition ') or
                       contains(@class, ' cxxStruct/cxxStructDefinition ') or
                       contains(@class, ' cxxUnion/cxxUnionDefinition ')]"
               mode="signature">
</xsl:template>

<!-- Use doxygen class names & html for members block -->
<xsl:template name="member-index-block">
  <xsl:param name="nodes" select="/.."/>
  <xsl:param name="title"/>
  <xsl:if test="$nodes">
    <table class="memberdecls">
      <thead>
        <tr>
          <th colspan="2" valign="left">
            <h2 align="left"><xsl:value-of select="$title"/></h2>
          </th>
        </tr>
      </thead>
      <tbody>
        <xsl:apply-templates select="$nodes" mode="class-members">
          <xsl:sort select="number(boolean(*[contains(@class, ' apiRef/apiDetail ')]/
                                             *[contains(@class, ' apiRef/apiDef ')]/
                                               *[contains(@class, ' apiRef/apiQualifier ')]
                                                [@name = 'constructor' or @name = 'destructor']))"
                    data-type="number" order="descending"/>
          <xsl:sort select="*[contains(@class, ' topic/title ')]"/>
        </xsl:apply-templates>
      </tbody>
    </table>
  </xsl:if>
</xsl:template>

<xsl:template match="*[contains(@class, ' cxxClass/cxxClassFunctionInherited ') or 
                         contains(@class, ' cxxClass/cxxClassVariableInherited ') or 
						 contains(@class, ' cxxClass/cxxClassTypedefInherited ') or 
                         contains(@class, ' cxxClass/cxxClassEnumerationInherited ') or 
                         contains(@class, ' cxxClass/cxxClassEnumeratorInherited ')]"
                mode="class-members">
    <tr>
      <td class="memItemLeft" align="right" valign="top"><xsl:text> </xsl:text></td>
      <td class="memItemRight" valign="bottom">
        <xsl:apply-templates select="."/>
      </td>
    </tr>
  </xsl:template>
  
<!-- Add links to all inherited members when the API item doing the inheriting is a struct -->
<xsl:template match="*[contains(@class, ' cxxStruct/cxxStructFunctionInherited ') or 
                       contains(@class, ' cxxStruct/cxxStructVariableInherited ') or 
				 contains(@class, ' cxxStruct/cxxStructTypedefInherited ') or 
                       contains(@class, ' cxxStruct/cxxStructEnumerationInherited ') or 
                       contains(@class, ' cxxStruct/cxxStructEnumeratorInherited ')]"
              mode="class-members">
  <tr>
    <td class="memItemLeft" align="right" valign="top"><xsl:text> </xsl:text></td>
    <td class="memItemRight" valign="bottom">
      <xsl:apply-templates select="."/>
    </td>
  </tr>
</xsl:template> 

<!-- Default member index row -->
<xsl:template match="*" mode="class-members" priority="0">
  <tr>
    <td class="memItemLeft" align="right" valign="top"><xsl:text> </xsl:text></td>
    <td class="memItemRight" valign="bottom">
      <a href="#{@id}">
        <xsl:apply-templates select="*[contains(@class, ' topic/title ')]" mode="cxxapiref.title-fmt"/>
       </a>
    </td>
  </tr>
</xsl:template>

<xsl:template match="*[contains(@class, ' cxxFunction/cxxFunction ')]" mode="class-members">
  <xsl:variable name="is-constructor">
    <xsl:call-template name="is-constructor"/>
  </xsl:variable>
  <tr>
    <td class="memItemLeft" align="right" valign="top">
      <xsl:apply-templates select="*[contains(@class, ' cxxFunction/cxxFunctionDetail ')]/
                                   *[contains(@class, ' cxxFunction/cxxFunctionDefinition ')]/
                                       *[contains(@class, ' cxxFunction/cxxFunctionVirtual ')]"/> 
      <xsl:apply-templates select="*[contains(@class, ' cxxFunction/cxxFunctionDetail ')]/
                                     *[contains(@class, ' cxxFunction/cxxFunctionDefinition ')]/
                                       *[contains(@class, ' cxxFunction/cxxFunctionPureVirtual ')]"/>                   
      <xsl:if test="not($is-constructor = 'true')">
        <xsl:apply-templates select="*[contains(@class, ' cxxFunction/cxxFunctionDetail ')]/
                                       *[contains(@class, ' cxxFunction/cxxFunctionDefinition ')]/
                                         *[contains(@class, ' cxxFunction/cxxFunctionDeclaredType ')]/node()"/>
      </xsl:if>
    </td>
    <td class="memItemRight" valign="bottom">
      <a href="#{@id}">
        <xsl:apply-templates select="*[contains(@class, ' topic/title ')]/node()"/><!--mode="cxxapiref.title-fmt"-->
      </a>
      <xsl:text>(</xsl:text>
      <xsl:for-each select="*[contains(@class, ' cxxFunction/cxxFunctionDetail ')]/
                              *[contains(@class, ' cxxFunction/cxxFunctionDefinition ')]/
                                *[contains(@class, ' cxxFunction/cxxFunctionParameters ')]/
                                  *[contains(@class, ' cxxFunction/cxxFunctionParameter ')]">
        <xsl:if test="not(position() = 1)">, </xsl:if>
        <xsl:apply-templates select="*[contains(@class, ' cxxFunction/cxxFunctionParameterDeclaredType ')]/node()"/>
      </xsl:for-each>
      <xsl:text>)</xsl:text>
    </td>
  </tr>
</xsl:template>

<!-- Variable member index row -->
<xsl:template match="*[contains(@class, ' cxxVariable/cxxVariable ')]" mode="class-members">
  <tr>
    <td class="memItemLeft" align="right" valign="top">
      <xsl:apply-templates select="*[contains(@class, ' cxxVariable/cxxVariableDetail ')]/*[contains(@class, ' cxxVariable/cxxVariableDefinition ')]/*[contains(@class, ' cxxVariable/cxxVariableDeclaredType ')]/node()"/>
    </td>
    <td class="memItemRight" valign="bottom">
      <a href="#{@id}">
        <xsl:apply-templates select="*[contains(@class, ' topic/title ')]/node()"/>
      </a>
    </td>
  </tr>
</xsl:template>

<!-- Enumeration member index row -->
<xsl:template match="*[contains(@class, ' cxxEnumeration/cxxEnumeration ')]" mode="class-members">
  <tr>
    <td class="memItemLeft" align="right" valign="top">
      <xsl:text>enum</xsl:text>
    </td>
    <td class="memItemRight" valign="bottom">
      <a href="#{@id}">
        <xsl:choose>
         <xsl:when test="starts-with(*[contains(@class, ' topic/title ')], '@')">
           <xsl:text>anonymous</xsl:text>
         </xsl:when>
         <xsl:otherwise>
           <xsl:apply-templates select="*[contains(@class, ' topic/title ')]/node()"/>
         </xsl:otherwise>
       </xsl:choose>
      </a>
      <xsl:text> { </xsl:text>
      <xsl:variable name="enumerators"
                    select="*[contains(@class, ' cxxEnumeration/cxxEnumerationDetail ')]/
                              *[contains(@class, ' cxxEnumeration/cxxEnumerationDefinition ')]/
                                *[contains(@class, ' cxxEnumeration/cxxEnumerators ')]/
                                  *[contains(@class, ' cxxEnumeration/cxxEnumerator ')]"/>
      
      <xsl:for-each select="*[contains(@class, ' cxxEnumeration/cxxEnumerationDetail ')]/
                              *[contains(@class, ' cxxEnumeration/cxxEnumerationDefinition ')]/
                                *[contains(@class, ' cxxEnumeration/cxxEnumerators ')]/
                                  *[contains(@class, ' cxxEnumeration/cxxEnumerator ')]">
        <xsl:if test="not(position() > 4)">
         <xsl:if test="not(position() = 1)">, </xsl:if>
         <a href="#{@id}">
           <xsl:apply-templates select="*[contains(@class, ' apiRef/apiName ')]/node()"/>  
         </a>
        </xsl:if>          
        <xsl:if test="position() = count($enumerators)">
          <xsl:if test="count($enumerators) > 5">
            <xsl:text>, ...</xsl:text>
          </xsl:if>
          <xsl:if test="count($enumerators) > 4">
            <xsl:text>, </xsl:text>
      <a href="#{@id}">
        <xsl:apply-templates select="*[contains(@class, ' apiRef/apiName ')]/node()"/>  
      </a>
       </xsl:if>
        </xsl:if>
      </xsl:for-each>
      <xsl:text> }</xsl:text>                        
    </td>
  </tr>
</xsl:template>

<xsl:template match="*[contains(@class, ' cxxTypedef/cxxTypedef ')]" mode="class-members">
  <tr>
    <td class="memItemLeft" align="right" valign="top">
      <xsl:text>typedef</xsl:text>
    </td>
    <td class="memItemRight" valign="bottom">
      <xsl:apply-templates select="*[contains(@class, ' cxxTypedef/cxxTypedefDetail ')]/
                                     *[contains(@class, ' cxxTypedef/cxxTypedefDefinition ')]/
                                       *[contains(@class, ' cxxTypedef/cxxTypedefDeclaredType ')]/node()"/>
      <xsl:text> </xsl:text>
      <a href="#{@id}">
        <xsl:apply-templates select="*[contains(@class, ' topic/title ')]/node()"/>
      </a>
    </td>
  </tr>
</xsl:template>

<!-- Override section heading, used to display member documentation -->
<xsl:template name="sect-heading">
  <xsl:param name="defaulttitle"/> <!-- get param by reference -->
  <xsl:variable name="heading">
     <xsl:choose>
      <xsl:when test="*[contains(@class,' topic/title ')]">
        <xsl:apply-templates select="*[contains(@class,' topic/title ')][1]" mode="text-only"/>
        <xsl:if test="*[contains(@class,' topic/title ')][2]">
          <xsl:apply-templates select="." mode="ditamsg:section-with-multiple-titles"/>
        </xsl:if>
      </xsl:when>
      <xsl:when test="@spectitle">
        <xsl:value-of select="@spectitle"/>
      </xsl:when>
      <xsl:otherwise/>
     </xsl:choose>
  </xsl:variable>

  <xsl:variable name="headCount">
    <xsl:value-of select="count(ancestor::*[contains(@class,' topic/topic ')])+1"/>
  </xsl:variable>
  <xsl:variable name="headLevel">
    <xsl:choose>
      <xsl:when test="$headCount > 6">h6</xsl:when>
      <xsl:otherwise>h<xsl:value-of select="$headCount"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="not($heading='')">
      <xsl:if test="normalize-space($heading)=''">
        <!-- hack: a title with whitespace ALWAYS overrides as null -->
        <xsl:comment>no heading</xsl:comment>
      </xsl:if>
      <xsl:apply-templates select="*[contains(@class,' topic/title ')][1]">
        <xsl:with-param name="headLevel" select="$headLevel"/>
      </xsl:apply-templates>
      <xsl:if test="@spectitle and not(*[contains(@class,' topic/title ')])">
		<div class="memitem">
			<div class="memproto">
			      <table class="memname">
			        <tbody>
			        <tr>
				        <xsl:element name="td">
				          <xsl:attribute name="class">memname</xsl:attribute>
				          <xsl:value-of select="@spectitle"/>
				        </xsl:element>
						<td>(</td>
						<td class="paramname"></td>
						<td>)</td>
						<td></td>
			        </tr>
			      </tbody></table>
			</div>
		</div>    
      </xsl:if>
    </xsl:when>
    <xsl:when test="$defaulttitle">
    	<xsl:choose>
	    	<xsl:when test="matches('Detailed Description', $defaulttitle) or
	    					matches('Member Type Definition Documentation', $defaulttitle) or
	    					matches('Member Attribute Documentation', $defaulttitle) or
	    					matches('Member Enumeration Documentation', $defaulttitle) or
	    					matches('Properties Documentation', $defaulttitle) or
	    					matches('Constructor &amp; Destructor Documentation', $defaulttitle) or
	    					matches('Member Function Documentation', $defaulttitle) or
	    					matches('Member Structure Documentation', $defaulttitle) or
	    					matches('Returns', $defaulttitle)
	    					">
				<xsl:element name="{$headLevel}">
					<xsl:attribute name="class">sectiontitle</xsl:attribute>
					<xsl:value-of select="$defaulttitle"/>
				</xsl:element>    		
	    	</xsl:when>
	    	<xsl:otherwise>
				<div class="memitem">
					<div class="memproto">
					      <table class="memname">
					        <tbody>
					        <tr>
						        <xsl:element name="td">
						        	<xsl:attribute name="class">memname</xsl:attribute>
						        	<xsl:value-of select="$defaulttitle"/>
						        </xsl:element>
								<td></td>
								<td class="paramname"></td>
								<td></td>
								<td></td>
					        </tr>
					      </tbody></table>
					</div>
					<div class="memdoc">
						<xsl:apply-templates select="../*" mode="doxygen-descs" />
					</div>					
				</div>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:when>
    <xsl:otherwise></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="*[contains(@class,' apiRef/apiDesc ')]"
              mode="doxygen-descs">
	<xsl:apply-templates select="." mode="sectionFormat" />
</xsl:template>

<xsl:template match="*" mode="doxygen-descs">
	<xsl:apply-templates select="*[contains(@class,' apiRef/apiDesc ')]" mode="doxygen-descs"/>
</xsl:template>

<xsl:template match="*[contains(@class,' apiRef/apiDesc ')]"
              mode="section-fmt">
  <xsl:apply-templates select="." mode="sectionFormat">
    <xsl:with-param name="titleType" select="''"/>
  </xsl:apply-templates>
</xsl:template>

<xsl:template match="*[contains(@class, ' cxxFunction/cxxFunctionDetail ')]" mode="section-fmt" />

<xsl:template match="*[contains(@class,' apiRef/apiDesc ') or
      				  contains(@class,' topic/example ')][ancestor::*[contains(@class,' apiRef/apiRef ')]]" 
      	      mode="sectionFormat">
  <xsl:param name="titleType"/>
  <xsl:call-template name="start-revflag"/>
  <xsl:apply-templates select="*[not(contains(@class,' topic/title '))] | text() | comment() | processing-instruction()" />
  <xsl:call-template name="end-revflag"/>
</xsl:template>

<!--  Override Class/Struct/Union/File API description to add a hr -->
<xsl:template match="*[contains(@class,' cxxClass/cxxClassDetail ') or
                        contains(@class, ' cxxStruct/cxxStructDetail ') or
                        contains(@class, ' cxxFile/cxxFileDetail ') or
                        contains(@class, ' cxxUnion/cxxUnionDetail ')]/*[contains(@class,' apiRef/apiDesc ')]">
      <h2>Detailed Description</h2>
      <xsl:call-template name="topic.section"/>
      <hr />     
</xsl:template>

</xsl:stylesheet>
